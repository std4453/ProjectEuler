package io.github.std4453.projecteuler;

import io.github.std4453.projecteuler.utils.Fibonacci;

import static io.github.std4453.projecteuler.utils.MathsHelper.pow;

/**
 * Problem #297: Zeckendorf Representation<br />
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * Starting with 1 and 2, the first 10 terms will be: {@code 1, 2, 3, 5, 8, 13, 21, 34,
 * 55, 89}.<br />
 * Every positive integer can be uniquely written as a sum of nonconsecutive terms of the
 * Fibonacci sequence. For example, {@code 100 = 3 + 8 + 89}.<br />
 * Such a sum is called the Zeckendorf representation of the number.<br />
 * For any integer {@code n>0}, let {@code z(n)} be the number of terms in the Zeckendorf
 * representation of n.<br />
 * Thus, {@code z(5) = 1, z(14) = 2, z(100) = 3} etc.<br />
 * Also, for {@code 0 < n < 10^6, Σz(n) = 7894453}.<br />
 * Find {@code Σz(n)} for {@code 0 < n < 10^17}.
 */
public class Problem297 {
	private static final long MAX = pow(10L, 17L);

	// Theorem 1. If fib(k) <= n < fib(k + 1), the Zeckendorf representation of n must
	// contain fib(k).
	// Proof: If the Zeckendorf representation of n doesn't contain fib(k), the maximum
	// sum of of nonconsecutive terms of the Fibonacci sequence can be at most:
	//   fib(k - 1) + fib(k - 3) + ... + fib(l), where l is 1 if k is odd and 2 if k even.
	// = -fib(l - 1) + fib(l - 1) + fib(l) + fib(l + 2) + ... + fib(k - 3) + fib(k - 1)
	// = -1 + fib(l + 1) + fib(l + 2) + fib(l + 4) + ... + fib(k - 1)
	// = ...
	// = -1 + fib(k) < fib(k) <= n
	// Therefore the Zeckendorf representation of n must contain fib(k).

	// With Theorem 1, it is obvious that Z(n) = Z(n - fib(k)) + 1.
	// Write ΣZ(i) for m <= i < n as Σ(m, n) for the sake of simplicity.
	// Now give an positive integer p, there is:
	//   Σ(fib(p), fib(p + 1))
	// = Σ(0, fib(p - 1)) + fib(p - 1)
	// = Σ(0, fib(p + 1)) - Σ(0, fib(p))
	// Let phi(n) be Σ(0, fib(n)), we get:
	// phi(n + 1) - phi(n) = phi(n - 1) + fib(n - 1)
	// Or: phi(n + 2) = phi(n + 1) + phi(n) + fib(n)
	// Let theta(n) be Σ(0, n), and for the same reason, there is:
	//   theta(n)
	// = Σ(0, n)
	// = Σ(0, fib(k)) + Σ(fib(k), n)
	// = Σ(0, fib(k)) + Σ(0, n - fib(k)) + n - fib(k)
	// = theta(n - fib(k)) + n - fib(k)) + phi(k)
	// Where fib(k) <= n < fib(k + 1).
	// With this recursive formula, we can easily evaluate theta(10^17).

	// Actually for both fib(n) and phi(n) (OEIS/A001629) there is a close-formed
	// formula, however in order to guarantee precision we still calculate them using
	// their recursive formula.

	private static long[] buildFibCache() {
		int index = Fibonacci.getMaxFibIndex(MAX);
		return Fibonacci.fibRangeLong(index);
	}

	private static long[] buildPhiCache(long[] fibs) {
		long[] phis = new long[fibs.length];
		phis[1] = 0;
		phis[2] = 1;
		for (int i = 3; i < phis.length; ++i)
			phis[i] = phis[i - 1] + phis[i - 2] + fibs[i - 2];
		return phis;
	}

	@SuppressWarnings("StatementWithEmptyBody")
	private static long theta(long n, long[] fibs, long[] phis) {
		int k = Fibonacci.getMaxFibIndex(n);
		long sum = 0;
		while (true) {
			n = n - fibs[k];
			sum += phis[k] + n;
			if (n == 0) return sum;

			// Here is a small trick:
			// Since fib(k) <= n < fib(k + 1), there is:
			// 0 <= n - fib(k) < fib(k - 1),
			// so if:
			// fib(k') <= n - fib(k) < fib(k' + 1),
			// there is k' <= k - 2.
			// And since n != 0 by now, there must be fibs[0] = fibs[1] = 1 > n, so
			// there's no need to set a lower bound for k.
			for (k -= 2; fibs[k] > n; --k) ;
		}
		// Since n must have a Zeckendorf representation, the loop will terminate
		// eventually.
	}

	public static void main(String[] args) {
		long[] fibs = buildFibCache();
		long[] phis = buildPhiCache(fibs);
		System.out.println(theta(MAX, fibs, phis));

		// Answer: 2252639041804718029
		// Complexity: O(log(MAX))

		// Homework:
		// 1. Prove that "Every positive integer can be uniquely written as a sum of
		// nonconsecutive terms of the Fibonacci sequence".

		// 2. Prove that:
		// phi(n) = (1 / 5) * (n - 1/sqrt(5)) * ((1 + sqrt(5)) / 2)^n +
		//          (1 / 5) * (n + 1/sqrt(5)) * ((1 - sqrt(5)) / 2)^n.
	}
}
